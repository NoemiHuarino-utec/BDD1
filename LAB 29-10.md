# Procesamiento y Optimizaci√≥n de  Consultas

### √çndices

‚Ä¢ Son estructuras que toman el par (llave, atributo) de una tabla para agilizar la b√∫squeda.

‚Ä¢ Se busca el atributo en el √≠ndice y se retornan las filas de los elementos encontrados.

‚Ä¢ Se buscan las filas en la tabla directamente.

OJITOüëÄ : 
* Puede existir indices o √≠ndices formados por atributos compuestos. Si mi √≠ndice est√° compuesto por 3 atributos y si solo uso 2, no existe √≠ndice.
* El mal uso de los √≠ndices puede provocar una PEOR performance de la consulta

### En PG Admin - uso de √≠ndices

* Primero, creamos una tabla en el esquema **public**:

```ruby
CREATE TABLE Prueba(
    uid int primary key,
    c1 int,
    c2 text,
    c3 numeric,
    c4 timestamp,
    c5 interval,
    c6 int
);
```

* Ahora, creamos datos aleatorios y veremos el **costo**, ¬øen cuanto tiempo se ejecuta?

```ruby
INSERT INTO Prueba select id,
random()*10000, 
md5(random()::text),
10000*random(), 
clock_timestamp(),
(random()*1000::int||' hour')::interval,
random()*99999
from generate_series(1,1000000) t(id);
```

Se demora poque Postgress lo separa en bloques.

#### ¬øC√≥mo saber que una consulta es lenta?

En Postgress podemos defnir cuanta memoria se necesita para resolver una consulta.

`EXPLAIN :`  muestra el plan de ejecuci√≥n de una declaraci√≥n. EXPLAIN notifica que se utiliza un *Seq Scan*: una secuencia, bloque por bloque, que lee los datos de la tabla Prueba.

* En Postgress, lo ejecutamos de la siguiente manera:

```ruby 
EXPLAIN SELECT * FROM prueba
```

###### ¬øQu√© es el costo?
* El primer valor 0.00 es el **costo** para obtener *la primera fila*. 
* El segundo valor 24286.00 son los **costos** para obtener *todas las filas*.
* Las filas (rows) son el n√∫mero aproximado de *filas devueltas* cuando se realiza una operaci√≥n de exploraci√≥n secuencial. El planificador devuelve este valor. En este caso, coincide con el n√∫mero real de filas en la tabla.
* El ancho(width)  es un *tama√±o promedio de una fila en bytes*.

* Ahora, a√±adimos **analyze**:

```ruby 
EXPLAIN (ANALYZE) SELECT * FROM prueba
```

El comando muestra los siguientes par√°metros:
* **Actual time**, es el tiempo real en milisegundos dedicado a obtener la primera fila y todas las filas, respectivamente.

* **Planning time**,  es el tiempo dedicado a obtener el plan de ejecuci√≥n.

* **rows**, es el n√∫mero real de filas recibidas con Seq Scan.

* **loops**, es el n√∫mero de veces que se tuvo que realizar la operaci√≥n Seq Scan.

* **Execution time**,  es el tiempo total de ejecuci√≥n de la consulta.

* Probamos **buffers**:

```ruby 
EXPLAIN (analyze, buffers) SELECT * FROM prueba;
```

* **Buffers**: *read* es el n√∫mero de bloques que PostgreSQL lee del disco.

* Leemos la tabla por bloques. Si el cach√© est√° vac√≠o. Tuvimos que acceder a 1914 bloques para leer toda la tabla del disco.

* **Buffers**: *shared hit* es el n√∫mero de bloques recuperados del cach√© PostgreSQL.

* A√±adimos un datos en nuestra consulta:

```ruby 
EXPLAIN (analyze, buffers) SELECT * FROM prueba where c1 > 100
```

Solo se filtran 10145 filas del 1 mill√≥n , son eliminadas del resultado. Nos quedamos 989855 filas


> ## Crear √≠ndices en SQL

La sintaxis es la sigueinte:

`CREATE INDEX nombre ON tabla(attr) USING method`

Donde significa:

‚Ä¢ nombre: el nombre del √≠ndice.

‚Ä¢ tabla(attr): la tabla y atributos sobre los que se construir√° el √≠ndice.

‚Ä¢ method: puede ser b-tree (por defecto), hash, GIN, etc.

* Siguiendo con nuestro ejemplo:

```ruby 
CREATE INDEX idx_prueba1 ON prueba USING btree (c1);
```

**¬øQu√© hace ese c√≥digo?** 
Aqui crea un √°rbol en base al atributo c1 para que la b√∫squeda sea m√°s r√°pida

Hemos notado que a pesar de ahora usar un btree, al ejecutar:

`EXPLAIN (analyze, buffers) SELECT * FROM prueba where c1 > 100` Postgrees desobedece y usa **seq scan**. 

Por ello, forzamos a que no use busqueda secuencial.

* Desactivaremos el escaneo secuencial:

```ruby 
SET enable_seqscan TO off;
```

* Luego, volvemos a ejecutar: 

```ruby 
EXPLAIN (analyze, buffers) SELECT * FROM prueba where c1 > 100
```

Al desactivarlo, el √≠ndice Bitmap Scan e Index Cond, utiliza el √≠ndice idx_prueba1 en lugar de Filter


> ## Visualizar gr√°ficamente la ejecuci√≥n de la consulta


* Para probarlo en Windows: ***Shif+F7***

**Usaremos nuestro esquema pelicula**.

* Ahora, ejecutamos:

<details><summary>Click aqu√≠ para ver c√≥digo üòé</summary>
<p>
   
   
```ruby
SELECT p_nombre,p_anho, COUNT(DISTINCT personaje)
FROM personaje P, actor A
WHERE P.a_nombre = A.nombre
AND A.genero = 'F'
GROUP BY p_nombre, p_anho
HAVING COUNT(DISTINCT personaje)=( SELECT  MAX(cantidad)
                                      FROM (
                                    SELECT p_nombre,p_anho, COUNT(DISTINCT personaje) AS cantidad
                                    FROM personaje P, actor A
                                    WHERE P.a_nombre = A.nombre
                                    AND A.genero = 'F'
                                    GROUP BY p_nombre, p_anho) Temp);
```

    
</p>
</details>
