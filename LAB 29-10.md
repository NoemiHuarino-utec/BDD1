# Procesamiento y OptimizaciÃ³n de  Consultas

### Ãndices

â€¢ Son estructuras que toman el par (llave, atributo) de una tabla para agilizar la bÃºsqueda.

â€¢ Se busca el atributo en el Ã­ndice y se retornan las filas de los elementos encontrados.

â€¢ Se buscan las filas en la tabla directamente.

OJITOðŸ‘€ : 
* Puede existir indices o Ã­ndices formados por atributos compuestos. Si mi Ã­ndice estÃ¡ compuesto por 3 atributos y si solo uso 2, no existe Ã­ndice.
* El mal uso de los Ã­ndices puede provocar una PEOR performance de la consulta

### En PG Admin - uso de Ã­ndices

* Primero, creamos una tabla en el esquema **public**:

```ruby
CREATE TABLE Prueba(
    uid int primary key,
    c1 int,
    c2 text,
    c3 numeric,
    c4 timestamp,
    c5 interval,
    c6 int
);
```

* Ahora, creamos datos aleatorios y veremos el **costo**, Â¿en cuanto tiempo se ejecuta?

```ruby
INSERT INTO Prueba select id,
random()*10000, 
md5(random()::text),
10000*random(), 
clock_timestamp(),
(random()*1000::int||' hour')::interval,
random()*99999
from generate_series(1,1000000) t(id);
```

Se demora poque Postgress lo separa en bloques.

#### Â¿CÃ³mo saber que una consulta es lenta?

En Postgress podemos defnir cuanta memoria se necesita para resolver una consulta.

`EXPLAIN :`  muestra el plan de ejecuciÃ³n de una declaraciÃ³n. EXPLAIN notifica que se utiliza un *Seq Scan*: una secuencia, bloque por bloque, que lee los datos de la tabla Prueba.

* En Postgress, lo ejecutamos de la siguiente manera:

```ruby 
EXPLAIN SELECT * FROM prueba
```

###### Â¿QuÃ© es el costo?
* El primer valor 0.00 es el **costo** para obtener *la primera fila*. 
* El segundo valor 24286.00 son los **costos** para obtener *todas las filas*.
* Las filas (rows) son el nÃºmero aproximado de *filas devueltas* cuando se realiza una operaciÃ³n de exploraciÃ³n secuencial. El planificador devuelve este valor. En este caso, coincide con el nÃºmero real de filas en la tabla.
* El ancho(width)  es un *tamaÃ±o promedio de una fila en bytes*.

* Ahora, aÃ±adimos **analyze**:

```ruby 
EXPLAIN (ANALYZE) SELECT * FROM prueba
```

El comando muestra los siguientes parÃ¡metros:
* **Actual time**, es el tiempo real en milisegundos dedicado a obtener la primera fila y todas las filas, respectivamente.

* **Planning time**,  es el tiempo dedicado a obtener el plan de ejecuciÃ³n.

* **rows**, es el nÃºmero real de filas recibidas con Seq Scan.

* **loops**, es el nÃºmero de veces que se tuvo que realizar la operaciÃ³n Seq Scan.

* **Execution time**,  es el tiempo total de ejecuciÃ³n de la consulta.

* Probamos **buffers**:

```ruby 
EXPLAIN (analyze, buffers) SELECT * FROM prueba;
```

* **Buffers**: *read* es el nÃºmero de bloques que PostgreSQL lee del disco.

* Leemos la tabla por bloques. Si el cachÃ© estÃ¡ vacÃ­o. Tuvimos que acceder a 1914 bloques para leer toda la tabla del disco.

* **Buffers**: *shared hit* es el nÃºmero de bloques recuperados del cachÃ© PostgreSQL.

* AÃ±adimos un datos en nuestra consulta:

```ruby 
EXPLAIN (analyze, buffers) SELECT * FROM prueba where c1 > 100
```

Solo se filtran 10145 filas del 1 millÃ³n , son eliminadas del resultado. Nos quedamos 989855 filas


### Crear Ã­ndices en SQL

La sintaxis es la sigueinte:

`CREATE INDEX nombre ON tabla(attr) USING method`

Donde significa:

â€¢ nombre: el nombre del Ã­ndice.

â€¢ tabla(attr): la tabla y atributos sobre los que se construirÃ¡ el Ã­ndice.

â€¢ method: puede ser b-tree (por defecto), hash, GIN, etc.

* Siguiendo con nuestro ejemplo:

```ruby 
CREATE INDEX idx_prueba1 ON prueba USING btree (c1);
```

**Â¿QuÃ© hace ese cÃ³digo?** 
Aqui crea un Ã¡rbol en base al atributo c1 para que la bÃºsqueda sea mÃ¡s rÃ¡pida

Hemos notado que a pesar de ahora usar un btree, al ejecutar:

`EXPLAIN (analyze, buffers) SELECT * FROM prueba where c1 > 100` Postgrees desobedece y usa **seq scan**. 

Por ello, forzamos a que no use busqueda secuencial.

* Desactivaremos el escaneo secuencial:

```ruby 
SET enable_seqscan TO off;
```

* Luego, volvemos a ejecutar: 

```ruby 
EXPLAIN (analyze, buffers) SELECT * FROM prueba where c1 > 100
```

Al desactivarlo, el Ã­ndice Bitmap Scan e Index Cond, utiliza el Ã­ndice idx_prueba1 en lugar de Filter


### Visualizar grÃ¡ficamente la ejecuciÃ³n de la consulta


Para probarlo en Windows: ***Shif+F7***

**Usaremos nuestro esquema pelicula**. -> [DataSet](https://gist.github.com/tchambil/c224d364a186159c90a4ff81e2cda5d7)

* Ahora, ejecutamos:

<details><summary>Click aquÃ­ para ver cÃ³digo ðŸ˜Ž</summary>
<p>
   
   
```ruby
SELECT p_nombre,p_anho, COUNT(DISTINCT personaje)
FROM personaje P, actor A
WHERE P.a_nombre = A.nombre
AND A.genero = 'F'
GROUP BY p_nombre, p_anho
HAVING COUNT(DISTINCT personaje)=( SELECT  MAX(cantidad)
                                      FROM (
                                    SELECT p_nombre,p_anho, COUNT(DISTINCT personaje) AS cantidad
                                    FROM personaje P, actor A
                                    WHERE P.a_nombre = A.nombre
                                    AND A.genero = 'F'
                                    GROUP BY p_nombre, p_anho) Temp);
```

    
</p>
</details>
